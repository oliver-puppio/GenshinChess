# GenshinChess


## 一、项目概述

该项目为塔防游戏。本游戏是基于【原神】的元素反应机制而设计开发的塔防游戏。游戏目标为在地图指定位置上安装特定类型的防御塔，以阻止路线上的怪物到达终点。防御塔有三种类型，冰元素塔、水元素塔和火元素塔；怪物有5种类型，且部分怪物对不同的元素也有不同的抵抗能力，需要玩家通过不同元素之间的相互配合，以更快地消灭路线上的敌人，取得最后的胜利。本项目借鉴了一般塔防游戏布阵设防的思路，使得操作界面亲切、玩家易上手；又加入了一般塔防游戏不具有的元素反应机制，增强了游戏的策略性。

### 1.1 项目范围

1.	游戏显示界面，包括启动页、帮助页、游戏界面；其中游戏界面中包括顶部导航栏（里面有游戏启动/暂停、重新开始和返回按钮）、游戏动画面板、建造面板三大类；
2.	游戏内元素反应原理设计、实现。
3.	游戏内各种类型的防御塔、怪物实体；
4.	游戏所需图片、音频资源；

### 1.2 项目活动记录

1. 在【11月20日 - 11月24日】内讨论选题，并最终决定开发塔防小游戏；完成了远程仓库的配置（https://gitee.com/oliver-puppio/GenshinChess）；
2. 在【11月25日 – 11月27日】内设计完成游戏的UML类图，并根据类图完成了初始框架的搭建。
3. 在【11月28日 – 12月1日】内补充了Monster及其子类、Monsters刷怪类的细节；
4. 在【12月2日  – 12月3日】内补充了Tower、Bullet类的细节，补充了测试图片，开始调试线程控制； 
5. 在【12月4日】测试了GUI，怪物行走基本正常；
6. 在【12月5日】更换了Monster的在刷怪类Monsters中的存储方式，使之容易实现线程控制；防御塔攻击显示正常；完成了元素反应的设计和初步实现；
7. 在【12月6日】修复了游戏暂停、重开的bug，并完成了高等怪物的元素抵抗机制；
8. 在【12月7日】新增了地图和美化了游戏内显示界面；
9. 在【12月8日】修复了异常；继续美化页面，撰写文档。

### 1.3 项目分工

Oliver	制定游戏规则、设计元素反应原理；设计和实现所有实体类；撰写开发文档

Yaoio	设计、实现游戏界面和实体类线程控制；搜集、创作游戏素材 ；项目调试、优化

## 二、项目需求

本游戏实现了传统塔防游戏的基本功能，还设计了元素反应的机制。此外，也实现了地图选关、游戏暂停、重开、退出、教程等功能。具体可分为如下几个部分：

1.	防御塔的购买、售卖、自动攻击；
2.	怪物的移动和受击；
3.	维护玩家金币值、生命值；
4.	游戏暂停、重开、退出；
5.	查看游戏教程。

## 三、系统设计

### 3.1  系统流程描述

在开始界面，玩家可以选择点击直接开始游戏或者进入帮助页面查看游戏教程。点击开始游戏后系统会随机加载一张地图然后进入游戏界面。在游戏界面里，顶部是导航栏，有开始、重新开始和退出三个按钮，点击最左边的开始按钮后会正式开启游戏。

游戏界面中，左上角显示玩家当前的金币数、生命值和剩余怪物数量。玩家点击开始后，路线上会产生怪物。点击路线旁的标志点可以安放防御塔。当剩余怪物数为0且剩余生命值大于0时，游戏胜利；若玩家生命值小于0，则游戏失败。在游戏时，根据怪物特点选择合适的防御塔，会增加取胜的概率。

### 3.2  系统特色功能

在传统塔防游戏的基础上，我们借鉴了【原神】游戏中的元素反应机制，为普通的塔防游戏带来了新的玩法。

#### 3.2.1  元素反应机制

元素反应机制是本游戏的核心玩法之一。在本游戏中，一共有三种元素：冰、火、水。它们之间可以两两产生反应，从而对被攻击的怪物产生一定效果。以下为元素反应表：
#### 3.2.2  怪物特性
既然元素反应能对防御塔攻击带来正面收益，若怪物只能乖乖地接受增强的伤害的话，那元素反应就不会带来新的游戏体验。所以我们设置了怪物的特性。我们一共有5种怪物，可分为两类，一种是普通怪物，有丘丘人、藏镜侍女、丘丘暴徒；另一种是精英怪物，有火系深渊法师、水系深渊法师。他们的特性如下表：

### 3.3  系统线程设计
本游戏需要实时和玩家的操作互动，也使用了大量动画技术。我们采用多线程技术实现这些功能。使用线程的有游戏界面类、动画面板类、防御塔类、怪物类、怪物产生控制类。为了实现重新开始和暂停控制，我们也使用了玩家对象作为锁机制，控制所有线程的运行。

在以上线程中，游戏界面类主要负责检测游戏是否被暂停或者重设、玩家是否取得胜利；动画面板类线程负责绘制所有实体对象的动画效果；防御塔类线程负责检查是否有怪物靠近、并投掷炮弹；怪物类线程负责向控制怪物向终点前近；怪物产生控制类负责根据地图参数，定期在指定地方产生新的怪物。

### 3.4 系统类图

### 3.5  关键代码
#### 3.5.1  元素反应的实现
实现元素反应时，我们考虑到了元素和反应结果，确定了元素反应状态图。为了更好地表达攻击时发生了哪种反应，以及这种反应给怪物带来了哪些效果。我们引入了空状态(Empty)和时间元素(Time)。我们规定所有怪物一开始都处于Empty状态，当接收到元素攻击，怪物状态发生改变，故我们设计了ElementState.reaction(element)方法；元素是会先附着在怪物身上，被触发反应才造成效果的，因此我们用Empty状态可以很好地把这一过程转化为元素反应，即Empty和特定元素反应，状态会变成“对应元素附着”；元素附着和反应结果都有一段持续时间，我们可以把这个过程想象成时该元素状态在Time元素下发生转换，得到了如下的状态图

#### 3.5.2  多线程控制
一局游戏中存在用于产生新怪物的Monsters线程、游戏中存活的每个怪Monster以及建造的每个防御塔Tower线程，这些线程都统一在一局游戏中，玩家暂停、继续以及重新开始本局游戏的操作都应当能够统一地控制本轮游戏中的所有线程。为此我们将玩家Player类作为控制类，每轮游戏中的各线程都引用该游戏对应的Player对象，并获取Player对象的方法判断线程是否应阻塞等待（暂停）、是否应该结束线程。

将Player设置为同步锁对象，当玩家选择暂停，会触发监听事件将Player标记为暂停，在此条件下，本局游戏所有相关的线程皆会因此阻塞，进入该Player对象的等待集。当玩家选择继续游戏，则鼠标监听事件将会取消该Player的暂停标记，并同时调用该对象的notifyAll()方法，唤醒等待集中的所有线程，使游戏在暂停后能够继续接着运行。

关于游戏的重置，我们设置Player的停止属性stopped为游戏中所有线程的判断条件，一旦该线程引用的Player对象为停止状态，线程将跳出循环，从而终止线程。

#### 3.5.3  画面渲染
前端界面部分我们全部使用JavaGUI的swing框架完成。相关类包括GenshinChess（继承JFrame）、StartPanel、HelpPanel以及GamePanel。GenshinChess采用卡片布局管理器，使能在各个面板方便切换显示。

考虑到GUI中JButton类型视觉效果欠佳，我们采用JLabel标签替代按钮，在JLabel中添加设置所需图片，并添加相应的监听事件，达到和JButton相同的按钮效果。

鼠标监听事件中，我们为每个JLabel标签设置了鼠标移入/移出监听，通过显示不同图片，提升用户视觉体验与交互效果。

除了静态页面的显示，游戏中我们还需不断刷新画面，以实现画面中怪的移动、塔攻击与子弹飞行。这里我们重写了相关类的paint()方法，根据游戏的当前状态绘制不同的静态图片，再通过AnimationPanel线程中run()方法循环调用该类的repanit()方法不停重绘，渲染出动态游戏画面。
Bullet,Tower,Monster,AnimationPanel的paint

#### 3.5.4  地图设计和使用
丰富的地图是游戏有趣的标准之一。为此我们设置了枚举类Map以方便地创建地图信息。在Map类中，可以自定义地图背景图片、防御塔的数量、怪物数量、刷怪规则、2条怪物路线。

在GamePanel被创建时，就会随机载入地图，并完成一些控件、实体的实例化。

Map

#### 3.5.5  怪物移动
怪物移动move方法在线程run方法中被循环调用。该方法会首先判断怪物是否处于冻结状态，若是则不执行，否则会改变怪物的位置和方向。若怪物是丘丘暴徒，还会增加是否处于火元素附着状态且护盾存在的判断，用来持续扣除该状态下的丘丘暴徒的护盾值。

Move方法调用完后，run方法还会调用removeElementInLoop方法进行元素状态的更新。该方法使用了一个初值为0的flagInElementShift，每当该方法被调用时，就会使得flagInElementShift的值加1，当其达到25时，就会让当前元素和Time元素反应，即更新状态到无元素附着状态。并让flagInElementShift的值重新归0。这样就实现了元素状态的刷新。

Monster.run

Monster.move

Monster.removeElementInloop

#### 3.5.6  防御塔守卫
防御塔线程不断调用setTarget方法，在setTarget方法中遍历怪物列表，若发现有存活的怪物在其攻击范围之内，则会发起攻击，返回Point2D类值对象。

当返回值不为空时，调用发射动画、并不停更改炮弹bullet的位置，炮弹运动到目标位置后调用其类的explode方法，对范围内怪物造成元素伤害，随后重置bullet的状态；当返回值为空，即没有找到目标时，则休息间隔时间，随后开始继续搜索目标。

Tower.run

Tower.setTarget

Bullet.explode和Bullet.reset


#### 3.5.7  怪物受击
当怪物受到攻击时，调用injury方法，在injury方法内完成生命值的扣除和怪物附着的元素的更新。由于蒸发和融化是瞬间反应完成的，所有injury传入的元素参数若导致了这两种反应的发生，则会再发生一次和Time元素的反应，从而将状态更新为Empty；否则则会保留下来，并通过removeElementInLoop()和move()的发生，更新怪物身上的元素状态。

针对特殊的丘丘暴徒、深渊法师，我们重载了injury方法，完善了其在护盾存在时应进行的操作。

## 四、总结

该项目前后历时两周时间。通过这次项目实战，小组成员熟练掌握了Java语言的基础语法，对多线程开发、GUI编程有了新的认识。虽然小组成员只有两人，但在开发过程中并未因为人少不足而浪费太多时间，相反，合理的项目目标、细致的工作任务分解、公开资源的收集、利用和开发工具的熟练使用，使我们取得了事半功倍的效果。

在本次项目中，小组成员表现出了如下的特点：

1.	熟练运用各种工具。项目选题一开始确立，就着手准备系统类图的绘制。根据系统类图，很快就完成了项目代码的框架布局。在开发过程中，远程仓库的使用让协同开发更高效，快捷键的熟练使用也加快了设计思路从思想到实现的转变；
2.	养成了良好的注释习惯。组内统一了注释的格式，使得代码可读性强，便于debug和开发新功能；
3.	具有较强的学习能力。当项目缺少图片素材时，小组成员能迅速上手画图软件，画出像素小人图片；当遇到难以解决的bug时，能通过查阅API文档、查找参考书等方式，找到规范的使用方法；
4.	积极参与、沟通及时。小组成员每天投入大量精力，遇到问题时都会及时反馈、共同解决。

